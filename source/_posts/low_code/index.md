---
title: Low Code
abbrlink: 476b6600
date: 2021-05-15 19:07:30
cover: /images/top/low_code.svg
top_img: /images/cover/low_code.svg
tags:

password: yanxianliang
message: 本文暂不开放，需要密码才可阅读.
wrong_pass_message: 密码错误，请输入正确的密码.
---
## 需求（为什么）
1. 为了减轻人才成本压力，减少相似平台大量前端人力成本投入。
2. 快速完成类似平台搭建和开发，开发生产力跟不上日益增长的业务需求。
3. C端网站支持个性化，尤其是电商类，支持商家店铺装修。
4. C端站群模式兴起，为了快速建站并实现风格各异，避免第三方平台计算站点相似度进行封站（facebook尤为显著）。
5. 拥抱新技术、新领域时事。
6. 提效降本 & 质量保障

## Low Code（是什么）
Low Code 中文是`"低代码"`，"低代码"是指少量代码开发，通过聚合、流程化等方式快速生成所需代码，开发人员仅需在生成代码基础上做少量二次开发、甚至不需要任何开发即可生成整个Web系统。

## 模式（怎么样）
Low Code从横向上分为两种模式，一种是少量代码二次开发，可以叫（Less Code），一种是真正无代码构建，称为No Code。

### Less Code
`Less Code`顾名思义是少量代码，即系统中大部分代码是通过可视化生成。最后依据生成的代码中进行少量二次开发即可完成整个前端项目。

- 方案一：源代码
  通过编辑器操作后同步生成代码文件，开发人员可以直接对代码进行二次开发，目前次方案大都出现在开发编辑器中，例如阿里的`umi 中 ui`，和`ice vscode插件`，以及一些第三方的开源项目[`Brick Design`](https://github.com/brick-design/brick-design)等。
  这些都是通过可视化编辑器，进行配置后生成项目代码，开发人员可以在生成代码基础上写上自己的业务逻辑，和响应处理。不需要再花较多事件在组件实现，布局实现上。可提升前端开发效率。

- 方案二：schema
  编辑器编辑后生成的是一段tree结构schema，schema直接保存在项目目录中，生成对应的json配置文件，系统中通过解析器模块直接解析schema完成页面组建，开发人员可针对schema做调整或添加其他属性传递到对应组件中进行二次开发，完成业务功能。例如阿里的[Landing Page](https://landing.ant.design/index-cn)。

>
> 方案一 优点在于源代码模式二次开发简单，复杂度低。  缺点在于 生成的组件最后比较臃肿，尤其组件较多时，生成在一个文件中造成页面代码可读性降低，复杂度变高，需要进行拆分调优。且在二次开发后无法继续使用编辑器进行调整，后续迭代需求需要开发人员进行全量开发。
> 方案二 优点在于 schema 是一个json，二次开发后仍可使用编辑器对schema进行二次编辑修改，同时保留二次开发中新增的属性，保留原有逻辑。缺点在于 二次开发仅能针对现有组件属性进行修改。schema中很难插入解析器中不识别的自定义组件。需要组件足够丰富，且需要实现解析器。

### No Code
`No Code`是`Low Code`更加`"局限"`且`"深入"`的一种模式。它的愿景是系统无需前端开发人员进行任何代码开发，直接通过配置和可视化编辑即可生成完整的Web系统。
和`Less Code`的区别是它不需要开发人员进行二次开发，通过配置即可完成，因此该方案适用群体定位为`PM（产品）`和`OP（运维）`。而`Less Code`只能在一定程度上减少前端开发的工作量，并不能完全释放前端资源，甚至在系统不健全的情况下给前端二次开发带来繁琐的代码结构调优问题，效率不升反降。

`"深入性"`：No Code极致化了`Low Code`的理念，不需要开发人员进行二次开发，仅PM和OP即可组件Web系统。释放了前端资源，前端资源可以去做更有价值的事，而不是大部分都消耗在重复UI开发中。
`"局限性"`：No Code完全放弃了二次开发，在业务场景比较复杂多样的不同平台上，不支持二次开发意味着定制了一套标准化规范，所有场景组合都需要系统实现，整个体系比较复杂，如果抽象不合理，最后整套系统会非常臃肿。

本质上，No Code和Less Code的方案二类似，都是通过schema贯穿编辑和页面渲染过程的。不同的在于 No Code将schema 保存在db中，渲染时直接通过db获取schema交给解析器渲染即可。不会保存在项目中进行二次开发。编辑器也是直接解析schema形成可视化编辑页面，通过可视化编辑修改schema后保存到服务端。
目前国内比较流行的有[`ivx`](https://www.ivx.cn/)，大部分大企业中都会有相应的系统，了解的如京东、淘宝等都有自己的可视化编辑系统，可以轻松定制和修改线上网页。目前对于整站使用Low Code搭建的了解不多，没有听说过相应的系统。



## 方案落地
公司启动站群项目，需要快速搭建C端电商网站，提出了可视化方案，使用No Code构建一套C端解析系统，B端编辑配置系统。{% post_link design/page-design `C端方案` %} [demo](https://nezha-front-t.vova.com.hk/cluster/modify/203)。C端整体来说架构是比较简单的，因为C端不需要原子化组件，需要的更多的是单纯的无关联性的业务组件。即组件与组件之间相互控制基本上不存在，需要相互控制的基本上会放在一个组件中。因此不涉及组件间状态控制、同步、更不涉及到流程化控制。有的仅仅是一些黑盒的业务组件。

因此，C端的Low Code 基本没有`普适性`，仅适用企业当前业务特性，无法推广，这也是为什么京东、淘宝拥有相关系统，但无法企业化的原因。


### B 端初步规划
早期和一位经验丰富的技术主管也讨论过B端的Low Code，他对这方面非常感兴趣，想要基于此实现一套企业化产品。甚至包括api也是通过`strapi`进行配置生成。期望服务端也进行资源解放。后因为各自时间问题，相关的研发小组没有能有效组建。
相比于C端，C端一个网站即可实现一套No Code系统，前期成本高一些，后期开发成本及线上运营成本非常低。虽然没有普适性，但实用性较强。而B端，本就是个中后台系统，再为每个中后台系统开发一套No Code，相当不理智，因此B端流行的是`Less Code`解决方案，而No Code方案需要更高的抽象性，需要与业务完全解耦，形成一套标准解决方案意义才重大。因此B端提出了更高的要求和普适性。

那么B端实现难点在哪里？
1. 更高的抽象：抽象能力在系统和业务架构中是一个非常重要的基础能力，对开发人员来说是一个比较大的挑战，前期的架构决定了后期系统的横向和纵向能力。
2. 与业务解耦：组件本身需要与业务进行解耦，即组件只能是基本的原子组件，不能是过于复合的复合组件。与业务解耦后在`parser`阶段又需要与对应业务逻辑进行关联，如何与业务进行关联是一个难点，而且每个系统中业务也存在差异，除常规的直接调用接口、form check、prompt等等，总会有一些不同系统之间的异化处理，这种问题或多或少会出现，例如有些系统需要在登陆后需要用户选择一个env，有些不需要，因此需要在方案中提前考虑进去。
3. 组件依赖：原子化之后带来的一个更大的问题就是原子组件之间的交互控制，数据同步，组件是相关联的，因此需要有组件关联的解决方案。
4. 流程化逻辑控制：例如，一个保存按钮需要先进行form check，再进行prompt确认，最后调用api执行save，最后返回列表。所以我们需要流程化实现方案。
5. api标准化：api需要标准化，例如Search组件查询Table DataSet，在不同的中后台系统中，入参和出参格式需要保持一致，即要实现规范化，或者No Code系统中支持一定的api格式转换配置功能。



### B 端方案
1. 组件抽象：基于原子组件进行封装，不涉及复杂的复合组件。在确定组件封装之前需要进行单个讨论。
2. 组件属性，参考C端实现，尤其需要考虑版本号问题，目录结构可做调整。需要进行版本号统计，以废弃低版本组件。
3. 差异化业务解耦：Hooks + 云代码方式（google gtm）。一期不需要考虑，一期仅完成基础组件及组件解析器，具体的业务在业务项目中完成，不需要放在云代码上，Hooks可能会用到。
4. 组件依赖：组件之间交互控制方式有eventBus和数据驱动两种模式。后面分析。
5. 流程化逻辑：有人会说事件队列，事件队列中事件按序执行，该方案对于异步流程会有问题，会阻塞后续其他事件交互，需要实现子事件队列，向多个事件中透传下一个事件或者形成回调地狱，耦合，复杂度较高。较佳方案是使用响应式编程，例如rxjs等。
6. api：每个系统api提前录入，组件与api绑定仅支持从列表中选择。http service层支持通用api结构转换。

##### eventBus & 数据驱动
都可以实现不同组件之间通信。eventBus是一个比较常规的技术方案，在任何技术栈中都可以使用，数据驱动适合在MV*架构中。
主要区别：
1. eventBus 通过事件传递的值只能对于当前已经render的组件生效，后render的组件无法同步该数据。eventBus还是要和状态管理配合使用。
2. eventBus 会造成代码可读性很低。
3. 数据驱动在控制UI的同时也可以控制逻辑处理，遵从MV*涉及规范
以Search为例，具体流程对比如下： 
   {% asset_img 1.png EventBus&数据驱动 %}

数据驱动流程更加简单，复杂度更加低，因此建议使用数据驱动。

##### 相关问题和方案：
- 数据驱动造成渲染问题：
全局状态管理，例如Redux系列，都是基于React Context实现的，而Context有一个比较大的缺点就是，从Provider开始，只要没有拦截的组件都会重新渲染。因此所有状态都放在全局来管理会造成大量不必要的重复渲染，带来性能问题。 
解决方案：[Recoil](https://recoiljs.org/)的接入，Recoil是Facebook针对Redux的问题而完全基于React内部机制实现的一个状态管理，支持atom原子模式，不会进行全量更新，仅更新依赖的组件。另外Recoil会支持更多的优化，目前处于内测孵化阶段，但主功能可正常使用。

- 流程化逻辑实现：
使用rxjs或Promise链式实现。推荐rxjs。
  
- http service：
需要支持schema模式实现api调用和处理，http 请求只能走hooks模式。需要使用状态管理中的值。
